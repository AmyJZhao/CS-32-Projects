
Descriptions of Public Member Functions:
The pure virtual functions in my Actor class are isCollidable(), isFriendlyOrEnemy(), isDamageable(), doSomething(), and identifier(). doSomething() should be a pure virtual function because every actor does something, and they each do it in their own way. I chose to make isCollidable(), isFriendlyOrEnemy(), isDamageable(), and identifier() pure virtual functions because these methods were intended to describe the different types of Actors to make it easier for StudentWorld to differentiate them. IsFriendlyOrEnemy() lets the user know if the Actor is on NachenBlaster's side or the aliens' side. IsDamageable() is a way to differentiate between the ships and the other actors. Identifier() is to identify individual types of aliens, projectiles, etc. Each Actor has these attributes of being a friendly, an enemy, damageable, or not damageable. Besides these methods, I also have initDoSomething(), which checks if the actor is still alive and, if it has flown off screen, sets its state to dead. Most actors go through these steps in their doSomething() function. isAlive() and setState() both monitor the actor's state. getWorld() returns a pointer to StudentWorld. flownOffScreen() checks if the actor has flown off screen. 

In my DamageableObject class, I have the virtual methods isAlive(), sufferDamage(), identifier(), isCollidable(), isDamageable(), and isFriendlyOrEnemy(). The isAlive() method looks at the number of hit points left and determines the state of the actor. The isCollidable() method returns true because damageable actors are collidable, while the identifier() method specifies what the damageable actor is. The isDamageable() method returns true. The isFriendlyOrEnemy() method is meant to be overrided by DamageableObject's derived classes. hitPoints(), increaseHitPoints(), and decreaseHitPoints() either access or mutate the number of hit points in DamageableObject.
I tested the pure virtual functions in my Damageable class by changing their values and observing the changes in behavior of the actors on the screen. Different things collided or didn't collide into each other when normally they should have. 

My Star and Explosion classes, besides its doSomething() method, simply implement Actor's pure virtual functions. Their sufferDamage() methods don't do anything.

My NachenBlaster class implements the virtual methods doSomething(), sufferDamage(), identifier(), and isFriendlyOrEnemy(). identifier() returns the constant NACHENBLASTER. isFriendlyOrEnemy() returns the constant FRIENDLY. Besides its other member functions increaseTorpedoes(), healthPct(), cabbagePct(), numTorpedoes(), and numCabbages(), my NachenBlaster class also has checkCol(), which checks for collisions with enemy ships or enemy projectiles when it moves. I decided not to put checkCol() in the DamageableObject() class because the method wouldn't know where to check for colliding aliens or not. The checkCol() method checks for collisions with actors that are only labeled ENEMY based on the isFriendlyOrEnemy() method. The sufferDamage() method takes two parameters, damage amount and cause. First, I damage the Nachenblaster by damage amount, and then based on the cause, call the StudentWorld's getSound() method based on the situation.

My Alien class implements the virtual methods sufferDamage(), identifier(),  isFriendlyOrEnemy(), beginCheckCollision(), fireProjectile(), damageCollidingPlayer(), possiblyDropGoodie(), checkAndUpdateFlightPlan(), and initAlienDoSomething(). isFriendlyOrEnemy() returns the constant ENEMY. initAlienDoSomething() checks if the alien is not alive or has flown off the screen. I chose to make initAlienDoSomething() a virtual function so that Snagglegon, which has a different rationale for flying out of bounds, could override it. initAlienDoSomething() uses initDoSomething() to check its state, since Smallgons and Smoregons that fly off the screen in BOTH directions are dead. beginCheckCollision() checks if the alien has collided with the player's projectiles or the player itself. doSomething() in each of Alien's derived classes uses beginCheckCollision() to check for collisions. fireProjectile() follows the probability of a Smallgon or Smoregon firing a projectile, and as a virtual function, allows the Snagglegon class to define its own fireProjectile() class based on its own probability. damageCollidingPlayer() calls the player's decreaseHitPoints() to damage the player. I was playing around with the sound, and thought this was the best solution to avoid conflicting sounds when both the alien's sufferDamage() method and the NachenBlaster's sufferDamage() method were called. checkAndUpdateFlightPlan() is a helper method to condense tasks in doSomething(). 

My Smallgon class only has its doSomething() method. My Smoregon class has the doSomething(), possiblyDropGoodie(), and sufferDamage() methods. possiblyDropGoodie() and sufferDamage() are overrided from the Alien class. My Snagglegon class has all those methods, along with checkAndUpdateFlightPlan(), fireProjectile(), initAlienDoSomethig(), beginCheckCollision(), and identifier(). Snagglegon overloads checkAndUpdateFlightPlan() from Alien because Snagglegon follows different steps for its flight plan. Snagglegon only fires torpedoes, so it implements its own fireProjectile() for that. Snagglegon also drops only Extra Life Goodies, so its possiblyDropGoodie() method is different too. Snagglegons don't disappear when they fly off screen in the y-direction, hence Snagglegons needs a different initial doSomething() helper method. They also do higher damage to player when collided with, so the Snagglegon class overrides beginCheckCollision(). The identifier() method identifies a Snagglegon as a Snagglegon. Snagglegons also increase player's score by a different value, so the Snagglegon class overrides. 

My Projectile class has the virtual methods isCollidable(), isDamageable(), isFriendlyOrEnemy(), identifier(), and sufferDamage(). isCollidable() returns true because projectiles can collide. isDamageable() returns false because projectiles are not damageable. isFriendlyOrEnemy() returns NA so Projectile's derived classes can override it. sufferDamage() is a useless method because projectiles don't suffer damage. Projectile's checkC() method, which isn't virtual, checks if the projectile has collided with an alien. I didn't make the checkC() method virtual because there's no need for Projectile's derived classes to override it. I also didn't implement doSomething() in Projectile because every projectile does something different.

My Cabbage class, besides doSomething(), only has isFriendlyOrEnemy(), which returns FRIENDLY. My Turnip class is the same, except its isFriendlyOrEnemy() method returns ENEMY. My Torpedo class has two virtual methods, isFriendlyOrEnemy() and identifier(), for its derived classes, PlayerLaunchedTorpedo and AlienLaunchedTorpedo, to override. The PlayerLaunchedTorpedo class's isFriendlyOrEnemy() method returns FRIENDLY, while the AlienLaunchedTorpedo class's isFriendlyOrEnemy() method returns ENEMY. 

My Goodie class has the virtual methods isCollidable(), isDamageable(), isFriendlyOrEnemy(), identifier(), and sufferDamage(). isCollidable() returns true because goodies can collide with the player. isDamageable() returns false because goodies are not damageable. isFriendlyOrEnemy() returns ENEMY. sufferDamage() is a useless method because goodies don't suffer damage. The other public method is checkCollide(), which checks if the goodie has collided with the player. The Goodie class's derived classes, RepairGoodie, ExtraLifeGoodie, and TorpedoGoodie, all only have doSomething() and identifier(). identifier() returns a constant that differentiates the types of goodies. 

My StudentWorld class, besides init(), move(), and cleanUp(), has the methods removeDeadGameObjects(), decStars(), decAliens(), killedAlien(), NachenBlasterDied(), NachenBlasterCompletedLevel(), addActor(), getPlayer(), collide(), getOneCollidingAlien(), collideWithProjectiles(), collideWithPlayer(), playerInLineOfFire(), and updateGameText(). 
removeDeadGameObjects() removes the dead game objects from Student World after every tick. decStars() decreases the number of stars so Student World knows to create more stars. decAliens() decreases the current number of aliens on the screen so Student World's move() method knows to create more aliens. killedAlien() increases the number of aliens destroyed so Student World knows when NachenBlaster has won the round. NachenBlasterDied() returns true if the NachenBlaster is dead and decreases the number of lives. NachenBlasterCompletedLevel() returns true if nachenblaster killed required number of aliens. addActor() adds an actor to StudentWorld's vector. getPlayer()returns a pointer to NachenBlaster. collide() returns true if the two Actors collide. If there's at least one alien that's collided with an actor, getOneCollidingAlien() returns a pointer to one of them; otherwise, return a null pointer. collideWithProjectiles() takes an Actor as a parameter and finds all the projectiles that collide with it. collideWithPlayer() returns true if the actor collides with NachenBlaster. playerInLineOfFire() returns true if player is within 4 pixels of the actor. updateGameText() updates the game text.

Design Assumptions:
I chose to put sufferDamage() in my Actor class as a pure virtual function even though stars and explosions don't suffer damage because I needed a way to make an alien suffer damage through the StudentWorld() class. I also chose to make the functions isCollidable(), isFriendlyOrEnemy(), isDamageable(), and identifier() to make it easier for me to identify the actors in StudentWorld's vector. For my Alien class, Smallgons and Smoregons are very similar to each other, but both are very different from Snagglegons. I chose to make several virtual functions, and implement them in my Alien class based on Smallgons and Smoregons. The Snagglegon class would override those virtual functions on its own, and I wouldn't have to make the same virtual functions in the Smallgon class and the Smoregon class. That's why I also chose not to have the Alien class implement doSomething(). Smallgons, Smoregons, and Snagglegons all do something different, but their doSomething() methods do some parts similarily, so I put methods like fireProjectile() in the Alien class so Smallgons, Smoregons, and Snagglegons could use them in their doSomething() methods.

Known Bugs:
The bugs in my classes relate to the playing of various sounds. While the video game does play the sounds correctly in some situations, in other situations it doesn't play the sounds at all. For example, when the Nachenblaster's projectiles destroy an alien ship, the SOUND_DEATH sound doesn't play. Even when the Nachenblaster's projectiles only damage a ship and not destroy it, the SOUND_BLAST sound doesn't play. In most cases, the SOUND_BLAST sound plays when a turnip or torpedo strikes the NachenBlaster. Sometimes though, the sound won't play. Furthermore, when the NachenBlaster completes a level, the SOUND_COMPLETED_LEVEL sound won't play. In summary, the various required sounds sometimes don't play as they should in my program.

Test:
I first implemented my Actor class and Star class. My Actor class didn't have as many methods as it does now, and my Star class only had its doSomething() method. To test that my barebones Actor class and Star class worked, I displayed the video game and verified that Stars were being successfully created, moved across the screen, and disappearing (getting deleted) once they went out of the screen. After I implemented the Star class, I implemented the Explosion class on the premise that it was similar to a star. I tested that the Explosion class worked by adding it to Student World at a random location and displaying it along with the stars. After implementing Star and Explosion, I implemented Damageable Object, so that I could also write my NachenBlaster (player) class. After implementing NachenBlaster to make it move, I added the NachenBlaster to Student World and displayed it in the video game and verified that I could use the direction keys to move the NachenBlaster. Once I implemented NachenBlaster, I implemented Alien, along with one of its derived classes, Smallgon. I verified Alien worked by adding a Smallgon to Student World and observed that it had the right dimensions, and that it moved. Next, I implemented Smoregon and Snagglegon. At this point, the video game only showed the stars, the Nachenblaster, and the Aliens moving. Next, I implemented barebones versions of the projectiles and the goodies. Once I had the Cabbage class implemented, I made the NachenBlaster shoot cabbages. Then, I implemented the Turnip class, and had the Aliens shoot Turnips and Torpedoes. I put in the probabilities later. Basing my implementation on the given framework, I made a Torpedo class and had two separate derived classes, PlayerLaunchedTorpedo and AlienLaunchedTorpedo. I implemented the classes and made the Nachenblaster and Snagglegons shoot torpedoes at each other. I implemented most of the virtual doSomething() methods, but they only checked the state of the actor and moved it. Then, I implemented the collisions, then put in the probabilities of the projectiles and implemented the Goodies. To implement the collisions, I added a lot of virtual methods to Actor, DamageableObject, Projectile, and Goodie. I tested the pure virtual functions in my Actor class by changing their values and observing the changes in behavior of the actors on the screen. Different things collided or didn't collide into each other when normally they should have. 