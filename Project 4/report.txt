The MyHash.h template I wrote may or may not work. I didn't have time to test its resizing thoroughly, or verify that it actually works. I also don't know whether my Decrypter() class accurately decrypts messages because I didn't have time to test the recursive function.

In my Tokenzier.cpp file, to implement TokenizerImpl's tokenize() method, I used a vector of strings to hold the separate words. I iterated through each character of the string and updated a length and an index variable every time. If the character was a separator, I used the index variable to extract a substring and push that substring to the vector. I then reset the length variable.
In my WordList.cpp file, I used a hash table that mapped a string to a vector of strings. For every word in the list, I found its letter pattern and added it to the hash table. I then pushed the word and all the words matching its letter pattern to the vector of strings stored in the hash table. To find each word's letter pattern, I used another hash table to associate a letter of the word with a pattern latter (ABCDEFG, etc.). After assembling the hash table, I iterated through each character of the word again and added its corresponding letter to a letter pattern string that I had the method return. In the loadWordList() method, I either associated a new letter pattern or pushed the word to the already existing letter pattern's vector. In the contains() method, I simply found the letter pattern of the word and found its vector in the hash table. Then, I iterated through the vector and returned true if the word was contained within the vector. Similarly, in the findCandidates() method, I found the letter pattern of the cipher word and examined the vector from the hash table. I compared every word in the vector to the currTranslation string and pushed the words that qualified into a separate vector, that I then returned.
My Translator class used a private struct Table to construct a linked list. Each "Table" (node) held a hash table and its corresponding "opposite" hash table. In the pushMapping() method, I made a new node and stored the new mappings in the node's tables. Then, I inserted the node into the linked list. The popMapping() method simply removed the top node. The getTranslation() method iterated through the ciphertext string and found its corresponding mappings in the top node's hash table.
My Decrypter class utilizes privately defined methods and a recursive helper function. My private function containsMapping() returns an integer that lets me know if there's already an existing mapping or if there's a conflicting mapping. My fullyTranslated() function lets me know if the string is fully translated. The numUntranslatedLetters() returns the number of untranslated letters, and thus the mostUntranslatedLetters() function returns a string that has the most untranslated letters out of a string of vectors.

Big O
My MyHash.h class fulfills all the Big-O requirements. My MyHash() constructor constructs 100 buckets, thus running in O(B) time. My reset() function also funs in O(B) time since it destructs all the buckets. My associate() function runs in O(1) time if the number of buckets does not change. If the number of buckets changes, it runs in O(X) time in order to replace all the associations. My find() function runs in O(1) time.
My TokenizerImpl class also fulfills all the Big-O requirements. My TokenizerImpl() constructor runs O(P) (P is # of separators) because it iterates once through the string of separators. My tokenize() method is made up of two nested loops, the outer loop running  S times (S = # of characters in input string S) and the inner loop running P times.
My WordListImpl class fulfills all the Big-O requirements. My loadWordList() method runs in O(W) time (W = # of words in text file) since it iterates through every word in the word file. My contains() method runs in O(1) method courtesy of using a hash table. Because I used letter patterns to index my word list data, it only takes O(1) time to access the vector of strings associated with the letter pattern. I iterate through the vector of strings to compare it to currTranslation. Thus, it only takes O(W) time.
My Translator class also fulfills the Big-O requirements. The function pushMapping() runs in O(N + L) time (N = length of parameter strings and L = number of letters in alphabet). 
